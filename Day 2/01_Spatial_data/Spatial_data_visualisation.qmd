---
title: "Visualizaci√≥n de datos espaciales"
author: "Tatiana Proboste"
format:
   html:
    embed-resources: true
    toc: true
editor: visual
output:
  xaringan::moon_reader:
    css: ['default','https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css', 'slides.css']
    lib_dir: libs
    in_header: 
      - 'targetblank.html'
    nature:
      navigation:
        scroll: false
      titleSlideClass: ['inverse','middle','left',my-title-slide]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "macros.js"
      ratio: '16:9'
bibliography: references.bib
---

üß≠ Qu√© Vamos a Aprender

En esta sesi√≥n de **visualizaci√≥n de datos espaciales**, exploraremos datos espaciales y aprenderemos a visualizar y modificarlos. El objetivo es que adquieras las herramientas necesarias para:

-   Acceder a datos de libre acceso

-   Realizar transformaciones, cambios de sistema de coordenadas (CRS), extracci√≥n y c√°lculos b√°sicos

-   Llevar a cabo la manipulaci√≥n de datos espaciales

### üóÇÔ∏è Organiza Tus Datos

Antes de comenzar a trabajar en R, una buena pr√°ctica es crear una nueva carpeta con el nombre de nuestro proyecto: **`visualizacion_espacial`**

Dentro de esta carpeta, se recomienda crear tres subcarpetas:

-   `raw_data` ‚Äì para los datos originales

-   `outputs` ‚Äì para los resultados, gr√°ficos o mapas

-   `scripts` ‚Äì para guardar nuestros c√≥digos en R

### üì¶ Cargar Librer√≠as

-   **`sf`** : significa *Simple Features*, y es fundamental para trabajar con datos espaciales vectoriales [@sf]

-   **`tmap`**: es un paquete especializado en la visualizaci√≥n de mapas de forma flexible [@tmap]

-   **`geodata`**: es un paquete que permite descargar datos clim√°ticos y ambientales de WorldClim directamente en R. Los datos est√°n disponibles para diferentes variables clim√°ticas, como temperatura, precipitaci√≥n, etc., y se pueden descargar en distintas resoluciones y per√≠odos de tiempo. [@geodata]

-   **`terra`**: es un paquete para trabajar con datos espaciales raster. [@terra]

```{r, echo=TRUE, warning=FALSE, output=FALSE}
library(tidyverse) # cleaning, wrangling 
library(adehabitatHR)
```

### Introducci√≥n

En esta sesi√≥n, exploraremos las funciones y paquetes b√°sicos necesarios para visualizar datos geoespaciales utilizando informaci√≥n sobre casos de influenza aviar en Chile (includos en la carpeta Day 2 \> raw_data\> 'data'.

Los datos se encuentran en un archivo CSV que contiene informaci√≥n de latitud y longitud. Primero, debemos acceder a los datos y **filtrar la informaci√≥n que no necesitamos**.

Una vez hecho esto, podremos **mapear los puntos donde est√°n ubicados los casos por especie**, utilizando un *shapefile* con los l√≠mites geogr√°ficos de Chile.

## 1. Datos de libre acceso.

El paquete **`chilemapas`** proporciona mapas vectoriales de las divisiones pol√≠tico-administrativas de Chile listos para usar en R. Incluye capas de **comunas**, **provincias** y **regiones**.

Este paquete provee directamente objetos de tipo **`sf`** (simple features) con la geometr√≠a de cada comuna. Trae adem√°s tablas con c√≥digos y nombres territoriales para realizar uniones. Por ejemplo, luego de cargar `chilemapas`, se puede acceder al *sf* de comunas con `mapa_comunas` y graficarlo o manipularlo con funciones de **ggplot2** o **sf**. Para obtener agregados por provincia o regi√≥n, el paquete ofrece funciones como `generar_provincias()` o `generar_regiones()` que combinan las comunas por c√≥digo territorial. En resumen, **chilemapas** entrega *‚Äúmapas terrestres con topolog√≠as simplificadas‚Äù* de Chile listos para usarse f√°cilmente en visualizaciones y an√°lisis.

```{r, echo=TRUE, warning=FALSE, output=F}
library(chilemapas)
library(sf)

print(mapa_comunas)
print(codigos_territoriales)

# Convertir expl√≠citamente a sf (por si perdi√≥ el atributo)
comunas <- st_as_sf(mapa_comunas) %>% 
  left_join(codigos_territoriales) 

library(ggplot2)
ggplot(comunas) +
  geom_sf(fill = "lightgreen", color = "gray") +
  labs(title = "Mapa de Chile por comunas") +
  theme_minimal()
```

Podemos dejar fuera la Isla de Pascua (Rapanui) para visualizar mejor el mapa continental.

```{r echo=TRUE, output=F}
comunas <-  comunas %>% filter(nombre_comuna!= "Isla de Pascua")

ggplot(comunas) +
  geom_sf(fill = "lightgreen", color = "gray") +
  labs(title = "Mapa de Chile por comunas") +
  theme_minimal()

# Guardar como archivo rds, que es un formato de R
saveRDS(comunas, file = "comunas.rds")
```

Datos de variables climaticas

Vamos a usar var = "tavg", que se refiere a la temperatura promedio. Para ver m√°s opciones de este paquete, podemos usar la funci√≥n ?geodata.

```{r, echo=F, warning=FALSE, output=F}
library(geodata)

chile_tavg <- worldclim_country("Chile", var="tavg", path=tempdir())
```

## 2. Cargar los datos de influenza aviar.

```{r, echo=T, warning=FALSE, output=F}
library(readr)

data <- read_csv("./Raw_data/data.csv",
                 locale = locale(encoding = "ISO-8859-1")) # significa que el archivo CSV contiene caracteres especiales (como acentos o s√≠mbolos) que no est√°n codificados correctamente para R. Esto suele pasar cuando: El archivo tiene codificaci√≥n UTF-8 (o ISO-8859-1) pero R lo intenta leer con otra. Hay s√≠mbolos no reconocidos, como √±, tildes (√°, √©‚Ä¶), comillas raras, etc.



```

### Limpiar datos

`janitor` es un paquete para limpiar bases de datos. Lo usaremos para limpiar los nombres de las columnas.

`stringi` es un paquete para limpiar valores de texto: quitar tildes y pasar a min√∫sculas.

```{r, echo=TRUE, warning=FALSE, output=F}
library(janitor)

data <- clean_names(data) 

library(stringi)

data <- data %>%
  mutate(across(where(is.character), ~ stri_trans_general(., "Latin-ASCII"))) %>%
  mutate(across(where(is.character), ~ str_to_lower(.)))

comunas<- comunas %>%
  mutate(across(where(is.character), ~ stri_trans_general(., "Latin-ASCII"))) %>%
  mutate(across(where(is.character), ~ str_to_lower(.)))
```

## 3. Visualizacion de datos

### 3.1 Puntos

Primero, vamos a usar un plot simple para ver como se distribuyen los puntos en el espacio.

**Puntos: usando *`ggplot`***

```{r, echo=TRUE, warning=FALSE, output=T}

ggplot(data, aes(x=longitude, y=latitude, color=especie))+ 
  geom_point()+  
  theme_bw() 
```

Tambi√©n podemos hacer una visualizaci√≥n interactiva usando **plotly**, un paquete que permite explorar informaci√≥n individual de cada punto.

```{r, echo=TRUE, warning=FALSE, output=FALSE}
library(plotly)
```

```{r, echo=TRUE, warning=FALSE, output=T}

ggplotly(
  ggplot(data, aes(x=longitude, y=latitude, color= especie))+ 
  geom_point()+  
  theme_bw() 
) 
```

**Puntos: usando *tmap*** (paquete para crear mapas)

Si intentamos usar los datos de los casos de influenza aviar con tmap, **no va a funcionar** directamente. Necesitamos transformar nuestra **base de datos** en un base de datos **espacial** usando la funci√≥n `st_as_sf()` del paquete sf.

```{r, echo=TRUE, warning=FALSE, output=T}
data_sp <-  st_as_sf(data, coords = c('longitude', 'latitude'), crs = 4326) # WGS 84

```

Antes de comenzar a mapear, necesitamos revisar el **Sistema de Referencia de Coordenadas (CRS)** del data frame espacial. El **CRS** define c√≥mo los elementos espaciales de los datos se relacionan con la superficie de la Tierra.

**Revisemos qu√© CRS tenemos** con la funci√≥n `st_crs()`\
Y si queremos **transformar el CRS**, usamos la funci√≥n `st_transform()`.

```{r, echo=T, warning=FALSE, output=F}
st_crs(data_sp) #EPSG:4326
st_transform(data_sp, 4283) #GDA94 
```

## Visualizaci√≥n Interactiva con `tmap_mode("view")`

`tmap` permite dos modos de visualizaci√≥n:

-   **`"plot"`**: modo est√°tico (ideal para informes impresos o PDF)

-   **`"view"`**: modo interactivo (permite explorar el mapa como en una aplicaci√≥n web)

En este caso, activamos el modo interactivo con `tmap_mode("view")`, lo que nos permite:

-   Mover el mapa

-   Hacer zoom

-   Ver informaci√≥n de los puntos

Luego, usamos `tm_shape()` para cargar el objeto espacial y `tm_dots()` para visualizar los puntos.

Una vez terminado, podemos volvemos al modo est√°tico con `tmap_mode("plot")`.

```{r, echo=TRUE, warning=FALSE, output=F}

library(tmap)

```

```{r, echo=TRUE, warning=FALSE, output=T}
tmap_mode('view')  # use 'plot' to turn off the interactive view

tm_shape(data_sp)+  
  tm_dots()

```

Ahora agregemos color por especie

```{r,echo=TRUE, warning=FALSE, output=T}

tm_shape(data_sp) +
  tm_dots(fill = "especie") +
  tm_scale(values = "Set2")  # define la paleta aqu√≠

```

Podemos mejorar el mapa y agregar una escala y comp√°s

```{r, echo=TRUE, warning=FALSE, output=T}
tmap_mode("plot")  # Aseg√∫rate de estar en modo est√°tico

mi_mapa <- tm_shape(comunas) + 
  tm_polygons(col = "grey10", fill_alpha = 0.1) +

  tm_shape(data_sp) +
  tm_dots(fill = "especie") +

  tm_scale(values = "Set2") +  # paleta de colores

  tm_layout(
    legend.outside = TRUE,               # ACTIVAR que la leyenda est√© fuera
    legend.outside.position = "right",   # derecha del mapa
    legend.title.size = 1.0,
    legend.text.size = 0.8,
    frame = FALSE                        # opcional: quita el marco del mapa
  ) +

  tm_compass(position = c("left", "bottom")) +
  tm_grid(lines = FALSE) +
  tm_scalebar(text.size = 0.4, position = c("left", "bottom"))

mi_mapa

```

Para guardar el mapa, podemos usar el siguiente c√≥digo:

```{r echo=T, warning=FALSE, output=F}
tmap_save(tm = mi_mapa, filename = "mapa_chile.png", width = 10, height = 7)

```

### 3.2 Pol√≠gonos

Ahora vamos a usar el shapefile de comunas y vamos a contar el n√∫mero de muestras tomadas por comuna.

```{r,echo=TRUE, warning=FALSE, output=F}
casos_por_comuna <- data %>% group_by(especie, comuna) %>% 
  summarise(total_muestras = sum(n_animal_muestreado))
  
casos_por_comuna_sp <- comunas %>% 
  left_join(casos_por_comuna, by = c("nombre_comuna" = "comuna")) 

```

Podemos crear un mapa interactivo tipo coropl√©tico con tmap. Para ello, vamos a filtrar solo las muestras de aves piquero, para simplificar el ejemplo.

```{r,echo=TRUE, warning=FALSE, output=T}

piqueros <- casos_por_comuna_sp %>% filter(especie == "piquero")

tmap_mode("view")

tm_shape(piqueros) +
  tm_fill('total_muestras') +
tm_shape(data_sp) +
  tm_dots(fill = "especie") +
  tm_scale(values = "Set2")  # define la paleta de colores aqu√≠
```

### 3.3 Raster

Usaremos los datos de temperatura que descargamos en el paso 'datos de libre acceso'.

```{r, echo=F, warning=FALSE, output=F}
head(chile_tavg)

```

Como ahora vamos a trabajar con un raster, tenemos que usar el paquete ***terra***.

```{r, echo=T, warning=FALSE, message=FALSE, output=F}
library(terra)

tmin_chile <- mask(chile_tavg, comunas)
 
```

```{r, echo=TRUE, warning=FALSE, output=T}

 tm_shape(tmin_chile$CHL_wc2.1_30s_tavg_1)+
   tm_raster()

```

## 4. Estimaci√≥n de densidad por Kernel

En este ejercicio, vamos a realizar un an√°lisis de densidad de kernel (KDE) para visualizar la distribuci√≥n espacial de casos de influenza aviar. Utilizaremos datos de puntos (data_sp) que representan ubicaciones de casos, y un shapefile con los l√≠mites comunales para superponer la informaci√≥n.

```{r,echo=TRUE, warning=FALSE, output=T}
library(adehabitatHR)
library(terra)

spd <- as_Spatial(data_sp) # Convertir a objeto espacial
  
# Calcular el KDE usando el paquete adehabitatHR
kde.output <- kernelUD(spd, h="href", grid = 1000)

kde <- rast(kde.output)  # convertir a raster

#  si las comunas son un objeto sf:
comunas <- vect(comunas)  # convertir a SpatVector

# cortar el raster a la extensi√≥n de las comunas
kde_clipped <- mask(kde, comunas)

# Plot con tmap
tm_shape(kde_clipped) +
  tm_raster("ud")


```

Usamos tmap para visualizar el resultado, mostrando la densidad de casos junto con los l√≠mites comunales.

```{r,echo=TRUE, warning=FALSE, output=T}
tm_shape(kde_clipped) +
  tm_raster(style = "cont", palette = "viridis", title = "Case Density") +
  tm_shape(comunas) +
  tm_borders(col = "black") +
  tm_layout(main.title = "Kernel Density of Avian Influenza Cases",
            legend.outside = TRUE)
```

Conclusi√≥n: El mapa resultante permite identificar las √°reas con mayor concentraci√≥n de casos, lo cual puede ser √∫til para priorizar esfuerzos de vigilancia o intervenci√≥n. La t√©cnica KDE es una herramienta para entender patrones espaciales a partir de datos puntuales.

## 5. An√°lisis extras

Juntar dos bases de datos, 'comunas', que es u poligono espacial, y la base de datos bajada de INE con la information de aves del censo.

### Descripci√≥n de variables:

```{r, echo=T, warning=FALSE, output=F}

aves <- read_csv("Raw_data/INE_seccion_10_aves.csv")

library(janitor)
aves <- clean_names(aves) # limpia los nombres de las columnas

# Limpiar valores de texto: quitar acentos y pasar a min√∫sculas
aves <- aves %>%
  mutate(across(where(is.character), ~ stri_trans_general(., "Latin-ASCII"))) %>%
  mutate(across(where(is.character), ~ str_to_lower(.)))

```

Esta tabla se encuentra en este [link](https://www.ine.gob.cl/docs/default-source/censo-agropecuario/base-de-datos/2021/documentos/manual-de-usuario-de-bases-de-datos.pdf?sfvrsn=79ab6fff_4).

![](images/INE_table.png) Podemos calcular cu√°ntas aves tenemos por comuna (para este ejemplo solo usaremos los datos de "GA185"

```{r, echo=T, warning=FALSE, output=T}

aves_comuna <- aves %>% 
  group_by(region) %>% # agrupa por region
  summarise(total_aves = sum(ga185, na.rm = TRUE)) %>% # sumamos todos los datos por region
  mutate(region = str_replace_all(region, "de ", "") %>%  
           str_trim()) %>% 
  mutate(region = str_replace_all(region, "del ", "") %>% 
           str_trim())

```

Agregemos estos datos a nuestros datos de casos de influenza aviar.

Este paso solo funcionar√° si todos los nombres en las dos bases de datos que estamos intentando unir coinciden exactamente. En la base de datos original (bajada del SAG), los nombres de las regiones fueron modificados para que coincidieran con los del censo de aves bajado del INA.

```{r}
# 
 full_data <- st_as_sf(comunas) %>% 
  left_join(aves_comuna, by = c("nombre_region" = "region")) 
head(full_data)

```

## Referencias

[sf Package Documentation](https://r-spatial.github.io/sf/)

[Introduction to mapping in R](https://medium.com/analytics-vidhya/mapping-australia-in-r-6ce092c48b49)

[Plotting simple features](https://r-spatial.github.io/sf/articles/sf5.html)

[tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

[Spatial Statistics for Data Science](https://www.paulamoraga.com/book-spatial/types-of-spatial-data.htm)

**Otros softwares para an√°lisis espaciales**

Para el an√°lisis de cl√∫steres, se puede utilizar **SaTScan**.\
Para la detecci√≥n de *hotspots*, se puede emplear **GeoDa**.
